error[E0433]: failed to resolve: there are too many leading `super` keywords
  --> ../rust-bitcoin/primitives/src/script/owned.rs:13:5
   |
13 | use super::Script;
   |     ^^^^^ there are too many leading `super` keywords

error[E0433]: failed to resolve: you might be missing crate `core`
 --> ../rust-bitcoin/primitives/src/script/owned.rs:3:5
  |
3 | use core::convert::Infallible;
  |     ^^^^
  |     |
  |     you might be missing crate `core`
  |     help: try using `std` instead of `core`: `std`

error[E0433]: failed to resolve: you might be missing crate `core`
 --> ../rust-bitcoin/primitives/src/script/owned.rs:5:5
  |
5 | use core::marker::PhantomData;
  |     ^^^^
  |     |
  |     you might be missing crate `core`
  |     help: try using `std` instead of `core`: `std`

error[E0433]: failed to resolve: you might be missing crate `core`
 --> ../rust-bitcoin/primitives/src/script/owned.rs:6:5
  |
6 | use core::ops::{Deref, DerefMut};
  |     ^^^^
  |     |
  |     you might be missing crate `core`
  |     help: try using `std` instead of `core`: `std`

error[E0432]: unresolved import `core`
 --> ../rust-bitcoin/primitives/src/script/owned.rs:4:5
  |
4 | use core::fmt;
  |     ^^^^
  |     |
  |     you might be missing crate `core`
  |     help: try using `std` instead of `core`: `std`

error[E0432]: unresolved import `encoding`
  --> ../rust-bitcoin/primitives/src/script/owned.rs:10:5
   |
10 | use encoding::{ByteVecDecoder, ByteVecDecoderError, Decodable, Decoder};
   |     ^^^^^^^^ use of unresolved module or unlinked crate `encoding`
   |
help: you might be missing a crate named `encoding`, add it to your project and import it in your code
   |
 3 + extern crate encoding;
   |

error[E0432]: unresolved import `internals`
  --> ../rust-bitcoin/primitives/src/script/owned.rs:11:5
   |
11 | use internals::write_err;
   |     ^^^^^^^^^ use of unresolved module or unlinked crate `internals`
   |
help: you might be missing a crate named `internals`, add it to your project and import it in your code
   |
 3 + extern crate internals;
   |

error[E0432]: unresolved import `crate::prelude`
  --> ../rust-bitcoin/primitives/src/script/owned.rs:14:12
   |
14 | use crate::prelude::{Box, Vec};
   |            ^^^^^^^
   |            |
   |            unresolved import
   |            help: a similar path exists: `std::prelude`

error[E0223]: ambiguous associated type
   --> ../rust-bitcoin/primitives/src/script/owned.rs:145:25
    |
145 |     fn deref(&self) -> &Self::Target { self.as_script() }
    |                         ^^^^^^^^^^^^
    |
help: use fully-qualified syntax
    |
145 -     fn deref(&self) -> &Self::Target { self.as_script() }
145 +     fn deref(&self) -> &<ScriptBuf<T> as std::ops::Receiver>::Target { self.as_script() }
    |

error[E0223]: ambiguous associated type
   --> ../rust-bitcoin/primitives/src/script/owned.rs:150:37
    |
150 |     fn deref_mut(&mut self) -> &mut Self::Target { self.as_mut_script() }
    |                                     ^^^^^^^^^^^^
    |
help: use fully-qualified syntax
    |
150 -     fn deref_mut(&mut self) -> &mut Self::Target { self.as_mut_script() }
150 +     fn deref_mut(&mut self) -> &mut <ScriptBuf<T> as std::ops::Receiver>::Target { self.as_mut_script() }
    |

error[E0223]: ambiguous associated type
   --> ../rust-bitcoin/primitives/src/script/owned.rs:170:65
    |
170 | ...&mut &[u8]) -> Result<bool, Self::Error> {
    |                                ^^^^^^^^^^^
    |
help: use fully-qualified syntax
    |
170 -     fn push_bytes(&mut self, bytes: &mut &[u8]) -> Result<bool, Self::Error> {
170 +     fn push_bytes(&mut self, bytes: &mut &[u8]) -> Result<bool, <ScriptBufDecoder<T> as std::convert::TryFrom>::Error> {
    |
170 -     fn push_bytes(&mut self, bytes: &mut &[u8]) -> Result<bool, Self::Error> {
170 +     fn push_bytes(&mut self, bytes: &mut &[u8]) -> Result<bool, <ScriptBufDecoder<T> as std::convert::TryInto>::Error> {
    |

error[E0223]: ambiguous associated type
   --> ../rust-bitcoin/primitives/src/script/owned.rs:175:28
    |
175 |     fn end(self) -> Result<Self::Output, Self::Error> { Ok(ScriptBuf::f...
    |                            ^^^^^^^^^^^^
    |
help: use fully-qualified syntax
    |
175 -     fn end(self) -> Result<Self::Output, Self::Error> { Ok(ScriptBuf::from_bytes(self.0.end()?)) }
175 +     fn end(self) -> Result<<ScriptBufDecoder<T> as std::future::IntoFuture>::Output, Self::Error> { Ok(ScriptBuf::from_bytes(self.0.end()?)) }
    |
175 -     fn end(self) -> Result<Self::Output, Self::Error> { Ok(ScriptBuf::from_bytes(self.0.end()?)) }
175 +     fn end(self) -> Result<<ScriptBufDecoder<T> as std::ops::BitOr>::Output, Self::Error> { Ok(ScriptBuf::from_bytes(self.0.end()?)) }
    |

error[E0223]: ambiguous associated type
   --> ../rust-bitcoin/primitives/src/script/owned.rs:175:42
    |
175 |     fn end(self) -> Result<Self::Output, Self::Error> { Ok(ScriptBuf::f...
    |                                          ^^^^^^^^^^^
    |
help: use fully-qualified syntax
    |
175 -     fn end(self) -> Result<Self::Output, Self::Error> { Ok(ScriptBuf::from_bytes(self.0.end()?)) }
175 +     fn end(self) -> Result<Self::Output, <ScriptBufDecoder<T> as std::convert::TryFrom>::Error> { Ok(ScriptBuf::from_bytes(self.0.end()?)) }
    |
175 -     fn end(self) -> Result<Self::Output, Self::Error> { Ok(ScriptBuf::from_bytes(self.0.end()?)) }
175 +     fn end(self) -> Result<Self::Output, <ScriptBufDecoder<T> as std::convert::TryInto>::Error> { Ok(ScriptBuf::from_bytes(self.0.end()?)) }
    |

error[E0223]: ambiguous associated type
   --> ../rust-bitcoin/primitives/src/script/owned.rs:183:21
    |
183 |     fn decoder() -> Self::Decoder { ScriptBufDecoder(ByteVecDecoder::ne...
    |                     ^^^^^^^^^^^^^
    |
help: if there were a trait named `Example` with associated type `Decoder` implemented for `ScriptBuf<T>`, you could use the fully-qualified path
    |
183 -     fn decoder() -> Self::Decoder { ScriptBufDecoder(ByteVecDecoder::new(), PhantomData) }
183 +     fn decoder() -> <ScriptBuf<T> as Example>::Decoder { ScriptBufDecoder(ByteVecDecoder::new(), PhantomData) }
    |

error: aborting due to 14 previous errors

Some errors have detailed explanations: E0223, E0432, E0433.
For more information about an error, try `rustc --explain E0223`.
